"use strict";(self.webpackChunkdatalogui_dev=self.webpackChunkdatalogui_dev||[]).push([[587],{2862:function(e,n,t){var o=t(6913),a=t(4772);try{"undefined"!=typeof window&&(window.datalog=o,window.useQuery=a.useQuery),void 0!==t.g&&(t.g.datalog=o,t.g.useQuery=a.useQuery)}catch(r){}console.log("Datalog is available in the console:",o)},5071:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return d},metadata:function(){return u},toc:function(){return l},default:function(){return m}});var o=t(7462),a=t(3366),r=(t(7294),t(3905)),s=(t(2862),["components"]),i={id:"recursive-queries",title:"Recursive Queries"},d=void 0,u={unversionedId:"examples/recursive-queries",id:"examples/recursive-queries",title:"Recursive Queries",description:"Recursive queries are a way of using a query to add data back into a query. It's",source:"@site/docs/examples/recursive-queries.md",sourceDirName:"examples",slug:"/examples/recursive-queries",permalink:"/docs/examples/recursive-queries",editUrl:"https://github.com/datalogui/datalogui.dev/edit/master/docs/examples/recursive-queries.md",tags:[],version:"current",frontMatter:{id:"recursive-queries",title:"Recursive Queries"},sidebar:"docs",previous:{title:"Queries with negation",permalink:"/docs/examples/queries-with-negation"},next:{title:"Bacon Numbers",permalink:"/docs/examples/bacon-numbers"}},l=[],c={toc:l};function m(e){var n=e.components,t=(0,a.Z)(e,s);return(0,r.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Recursive queries are a way of using a query to add data back into a query. It's\na tool that let's you define complex logic in a simple way."),(0,r.kt)("p",null,"A classic problem in computer science is figuring out if a given graph of nodes\nis connected or not. We say a graph is connected if you can reach every node\nfrom every other node. We'll solve this problem to demonstrate recursive\nqueries."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"live noInline",live:!0,noInline:!0},"// Build our tables\n// This represents the nodes we've seen in our traversal so far.\n// We know if a graph is connected if every node is present in this table\nconst Nodes = datalog.newTable({\n    node: datalog.NumberType,\n})\n\n// This represents the edges between nodes\n// For example {from: 1, to: 2} represents an edge from node 1 to node 2\nconst Edges = datalog.newTable({\n    from: datalog.NumberType,\n    to: datalog.NumberType,\n})\n\n// Some initial Edges data\nconst initialEdgesData = [\n    [1, 2],\n    [2, 3],\n    [3, 4],\n    [4, 5]\n]\ninitialEdgesData.forEach(([from, to]) => {\n    Edges.assert({ from, to })\n})\n\n// We'll start the search at node 1. This could be any node\nconst initialNodesData = [\n    [1],\n]\ninitialNodesData.forEach(([node]) => {\n    Nodes.assert({ node })\n})\n\nconst Query = datalog.query(({ node, to }) => {\n    Nodes({ node })\n    Edges({ from: node, to })\n})\n\nQuery.viewExt().mapEffect(({kind, datum}) => {\n  // Because this datalog is differential we have to handle the cases\n  // where datum is Added, Removed, or Modified\n  if (kind === datalog.Added) {\n    Nodes.assert({node: datum.to})\n  } else if (kind === datalog.Removed) {\n    // We do the opposite of what we did above\n    Nodes.retract({node: datum.to})\n  } else {\n    // Here for completeness, but We don't get a modification kind from queries.\n    throw new Error(\"Unexpected modification. Shouldn't happen\")\n\n  }\n}).onChange(() => Query.runQuery()) // Rerun the query when the inputs change\n\n\nconst NodesConnectedTo1 = () => (\n  <pre>\n    {JSON.stringify(Nodes.view().readAllData().map(({node}) => node))}\n  </pre>\n)\n\nrender(<NodesConnectedTo1 />)\n")),(0,r.kt)("p",null,"Most of the code above is boilerplate setup code, the real meat is this query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const Query = datalog.query(({ node, to }) => {\n    Nodes({ node })\n    Edges({ from: node, to })\n})\n\nQuery.viewExt().mapEffect(({kind, datum}) => {\n  // Because this datalog is differential we have to handle the cases\n  // where datum is Added, Removed, or Modified\n  if (kind === datalog.Added) {\n    Nodes.assert({node: datum.to})\n  } else {\n    Nodes.retract({node: datum.to})\n  }\n  //...\n}).onChange(() => Query.runQuery()) // Rerun the query when the inputs change\n")),(0,r.kt)("p",null,"The trick is that we assert new data on the table whenever the query gives us\nnew data. We are essentially feeding data from a query back into the table."),(0,r.kt)("p",null,"This pattern is common enough that we added a shortcut:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const Query = datalog.query(({ node, to }) => {\n    Nodes({ node })\n    Edges({ from: node, to })\n}).implies(({ to }) => {\n    Nodes({ node: to })\n})\n")),(0,r.kt)("p",null,"Is the same thing, but much more concise. Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"implies")," method is very\nlimited, and if you do anything more complicated you will probably want the\n",(0,r.kt)("inlineCode",{parentName:"p"},"mapEffect")," method instead. Next we'll look at an even more complex example:\nBacon Numbers!"))}m.isMDXComponent=!0}}]);