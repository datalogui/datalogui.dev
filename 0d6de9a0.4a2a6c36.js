(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{142:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"metadata",(function(){return i})),t.d(n,"rightToc",(function(){return d})),t.d(n,"default",(function(){return l}));var o=t(1),a=t(9),s=(t(0),t(177)),r=(t(181),{id:"recursive-queries",title:"Recursive Queries"}),i={id:"examples/recursive-queries",title:"Recursive Queries",description:"import '../../src/globalDatalog'",source:"@site/docs/examples/recursive-queries.md",permalink:"/docs/examples/recursive-queries",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/examples/recursive-queries.md",sidebar:"docs",previous:{title:"Queries with negation",permalink:"/docs/examples/queries-with-negation"},next:{title:"Bacon Numbers",permalink:"/docs/examples/bacon-numbers"}},d=[],c={rightToc:d};function l(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(s.b)("wrapper",Object(o.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(s.b)("p",null,"Recursive queries are a way of using a query to add data back into a query. It's\na tool that let's you define complex logic in a simple way."),Object(s.b)("p",null,"A classic problem in computer science is figuring out if a given graph of nodes\nis connected or not. We say a graph is connected if you can reach every node\nfrom every other node. We'll solve this problem to demonstrate recursive\nqueries."),Object(s.b)("pre",null,Object(s.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts",metastring:"live noInline",live:!0,noInline:!0}),"// Build our tables\n// This represents the nodes we've seen in our traversal so far.\n// We know if a graph is connected if every node is present in this table\nconst Nodes = datalog.newTable({\n    node: datalog.NumberType,\n})\n\n// This represents the edges between nodes\n// For example {from: 1, to: 2} represents an edge from node 1 to node 2\nconst Edges = datalog.newTable({\n    from: datalog.NumberType,\n    to: datalog.NumberType,\n})\n\n// Some initial Edges data\nconst initialEdgesData = [\n    [1, 2],\n    [2, 3],\n    [3, 4],\n    [4, 5]\n]\ninitialEdgesData.forEach(([from, to]) => {\n    Edges.assert({ from, to })\n})\n\n// We'll start the search at node 1. This could be any node\nconst initialNodesData = [\n    [1],\n]\ninitialNodesData.forEach(([node]) => {\n    Nodes.assert({ node })\n})\n\nconst Query = datalog.query(({ node, to }) => {\n    Nodes({ node })\n    Edges({ from: node, to })\n})\n\nQuery.viewExt().mapEffect(({kind, datum}) => {\n  // Because this datalog is differential we have to handle the cases\n  // where datum is Added, Removed, or Modified\n  if (kind === datalog.Added) {\n    Nodes.assert({node: datum.to})\n  } else if (kind === datalog.Removed) {\n    // We do the opposite of what we did above\n    Nodes.retract({node: datum.to})\n  } else {\n    // Here for completeness, but We don't get a modification kind from queries.\n    throw new Error(\"Unexpected modification. Shouldn't happen\")\n\n  }\n}).onChange(() => Query.runQuery()) // Rerun the query when the inputs change\n\n\nconst NodesConnectedTo1 = () => (\n  <pre>\n    {JSON.stringify(Nodes.view().readAllData().map(({node}) => node))}\n  </pre>\n)\n\nrender(<NodesConnectedTo1 />)\n")),Object(s.b)("p",null,"Most of the code above is boilerplate setup code, the real meat is this query:"),Object(s.b)("pre",null,Object(s.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),"const Query = datalog.query(({ node, to }) => {\n    Nodes({ node })\n    Edges({ from: node, to })\n})\n\nQuery.viewExt().mapEffect(({kind, datum}) => {\n  // Because this datalog is differential we have to handle the cases\n  // where datum is Added, Removed, or Modified\n  if (kind === datalog.Added) {\n    Nodes.assert({node: datum.to})\n  } else {\n    Nodes.retract({node: datum.to})\n  }\n  //...\n}).onChange(() => Query.runQuery()) // Rerun the query when the inputs change\n")),Object(s.b)("p",null,"The trick is that we assert new data on the table whenever the query gives us\nnew data. We are essentially feeding data from a query back into the table."),Object(s.b)("p",null,"This pattern is common enough that we added a shortcut:"),Object(s.b)("pre",null,Object(s.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),"const Query = datalog.query(({ node, to }) => {\n    Nodes({ node })\n    Edges({ from: node, to })\n}).implies(({ to }) => {\n    Nodes({ node: to })\n})\n")),Object(s.b)("p",null,"Is the same thing, but much more concise. Note that the ",Object(s.b)("inlineCode",{parentName:"p"},"implies")," method is very\nlimited, and if you do anything more complicated you will probably want the\n",Object(s.b)("inlineCode",{parentName:"p"},"mapEffect")," method instead. Next we'll look at an even more complex example:\nBacon Numbers!"))}l.isMDXComponent=!0},181:function(e,n,t){"use strict";(function(e){var n=t(183),o=t(186);try{"undefined"!=typeof window&&(window.datalog=n,window.useQuery=o.useQuery),void 0!==e&&(e.datalog=n,e.useQuery=o.useQuery)}catch(a){}console.log("Datalog is available in the console:",n)}).call(this,t(75))}}]);